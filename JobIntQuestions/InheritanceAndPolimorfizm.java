Разница интерфейсов и абстрактных классов (наследование):
Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), в то время как у абстрактного класса они могут быть.

Абстрактный класс наследуется (etxends), а интерфейс — реализуется (implements). Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.

Абстрактные классы используются, когда есть отношение "is-a", то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом. 
(имплементация интерфейсов) гибче так как наследовать принято только от одного класса
(не считая суперкласса Object)
  а интерфейсы можно имплементировать от нескольких классов плюс одно поведение может
 использоваться в классах которые не подошли бы к идее наследования.
Соответственно проще дописывать код.

Поскольку в опубликованный интерфейс практически невозможно 
добавить новый метод, в случае потенциальной необходимости 
доработки лучше использовать абстрактный класс.
 Развивать абстрактные классы в Java проще, чем интерфейсы.
 Аналогично, если в интерфейсе слишком много методов и реализация
 их всех становится настоящей головной болью, лучше создать
 абстрактный класс для реализации по умолчанию. 


Этому паттерну следуют и в пакете коллекций Java,
 абстрактный класс AbstractList обеспечивает реализацию
  по умолчанию для интерфейса List.



Разница наследования и композиции:
наследование лучше использовать точно по назначению так как сильная связь между классами.
Использовать именно тогда когда объект добавляет еще поведение к родительскому
(то есть в реализации метода используется реализация наследуемая от супер класса + дочернего)
public void roam() {
super.roam();
тут доп код присущий дочернему классу;
}

Разница полиморфизма ad hoc и параметрического полиморфизма:


процедурное программирование Основная идея процедурного программирования - это разложение программы на подпрогаммы которые можно использовать повторно чтобы
не переписывать каждый раз. Разложенная программа (decomposed) имеет модульную структуру во избежании одного огромного
куска программы в главном методе main так как модульную структуру гораздо проще изменять и поддерживать

        }

// продолжение следует
